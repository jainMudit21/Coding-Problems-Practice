URL: https://leetcode.com/problems/insert-into-a-sorted-circular-linked-list/


/*
// Definition for a Node.
class Node {
    public int val;
    public Node next;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _next) {
        val = _val;
        next = _next;
    }
};
*/

class Solution {
    public Node insert(Node head, int insertVal) {
        
        if(head == null) {
            Node nhead = new Node(insertVal);
            nhead.next = nhead;
            return nhead;
        }
        
        Node returnMe = head;
        Node curr = head;
        
        if(curr.val == insertVal) {
            
            Node newNode = new Node(insertVal);
            newNode.next = curr.next;
            curr.next = newNode;
            
            return returnMe;
        }else if(curr.val > insertVal) {
            
            Node matchMe = curr;
            int max = curr.val;
            
            while(curr.next != matchMe && curr.next.val > insertVal && curr.next.val >= max) {
                if(curr.next.val < max) {
                    break;
                }
                max = curr.next.val;
                curr = curr.next;
            }
            if(curr.next == matchMe) {
                Node newNode = new Node(insertVal);
                newNode.next = curr.next;
                curr.next = newNode;
            }else if(curr.next.val < insertVal) {
                curr = curr.next;
                while(curr.next.val < insertVal) {
                    curr = curr.next;
                }
                Node newNode = new Node(insertVal);
                newNode.next = curr.next;
                curr.next = newNode;
            }else if(curr.next.val < max) {
                Node newNode = new Node(insertVal);
                newNode.next = curr.next;
                curr.next = newNode;
            }
        }else if(curr.val < insertVal) {
            
            Node matchMe = curr;
            int max = curr.val;
            
            while(curr.next != matchMe && curr.next.val < insertVal && curr.next.val >= max) {
                if(curr.next.val < max) {
                    break;
                }
                max = curr.next.val;
                curr = curr.next;
            }
            if(curr.next == matchMe) {
                Node newNode = new Node(insertVal);
                newNode.next = curr.next;
                curr.next = newNode;
            }else if(curr.next.val >= insertVal) {
                Node newNode = new Node(insertVal);
                newNode.next = curr.next;
                curr.next = newNode;
            }else if(curr.next.val < max) {
                Node newNode = new Node(insertVal);
                newNode.next = curr.next;
                curr.next = newNode;
            }
        }
        
        return returnMe;
    }
}


//refactored

/*
// Definition for a Node.
class Node {
    public int val;
    public Node next;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val, Node _next) {
        val = _val;
        next = _next;
    }
};
*/

class Solution {
    public Node insert(Node head, int insertVal) {
        
        if(head == null) {
            Node nhead = new Node(insertVal);
            nhead.next = nhead;
            return nhead;
        }
        
        Node returnMe = head;
        Node curr = head;
        
        if(curr.val == insertVal) {
            
            Node newNode = new Node(insertVal);
            newNode.next = curr.next;
            curr.next = newNode;
            
        }else if(curr.val > insertVal) {
            
            Node matchMe = curr;
            int max = curr.val;
            
            while(curr.next != matchMe && curr.next.val > insertVal && curr.next.val >= max) {
                max = curr.next.val;
                curr = curr.next;
            }
            if(curr.next == matchMe) {
                Node newNode = new Node(insertVal);
                newNode.next = curr.next;
                curr.next = newNode;
            }else if(curr.next.val < insertVal) {
                curr = curr.next;
                while(curr.next.val < insertVal) {
                    curr = curr.next;
                }
                Node newNode = new Node(insertVal);
                newNode.next = curr.next;
                curr.next = newNode;
            }else if(curr.next.val < max) {
                Node newNode = new Node(insertVal);
                newNode.next = curr.next;
                curr.next = newNode;
            }
        }else if(curr.val < insertVal) {
            
            Node matchMe = curr;
            int max = curr.val;
            
            while(curr.next != matchMe && curr.next.val < insertVal && curr.next.val >= max) {
                max = curr.next.val;
                curr = curr.next;
            }
            Node newNode = new Node(insertVal);
            newNode.next = curr.next;
            curr.next = newNode;
        }
        
        return returnMe;
    }
}
